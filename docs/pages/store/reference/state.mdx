import {Badge} from '../../../';

# State <Badge type={'class'}>Class</Badge>

Represents a concrete state in a reactive store, extending the functionality of `AbstractState`.
This class encapsulates the logic for updating, resetting and maintaining a state, reacting to
changes, and notifying subscribers whenever the state is updated.

It can also be connected to external data sources to synchronize its value with external data,
ensuring consistency across different parts of an application

`@template T {:ts}`  
The type of data managed and emitted by the state

## API

```ts copy
class State<T> extends AbstractState<T> {
  readonly $: Observable<T>;
  initialize(): this;
  complete(): void;
  manage(...operators: OperatorFunction<T, T>[]): this;
  get(): T;
  set(value: T): this;
  update(updater: (state: T) => T): this;
  reset(): this;
  compareBy(comparison: Comparison): this;
  connect(source: DataSource<T>): this;
  useLazyEmission(): this;
  useLazyEmissionOnce(): this;
  select<I extends any[]>(...inputs: [...EmitterOrObservableTuple<I>, SpreadFn<I, T>]): this;
  zip<I extends any[]>(...inputs: [...EmitterOrObservableTuple<I>, SpreadFn<I, T>]): this;
  wait<I extends any[]>(...inputs: [...EmitterOrObservableTuple<I>, SpreadFn<I, T>]): this;
  receive(...inputs: EmitterOrObservable<T>[]): this;
  receive<I>(input: EmitterOrObservable<I>, reducer: (value: I, state: T) => T): this;
  transmit(...outputs: (EmitterOrSubject<T> | EmitterOrSubject<void>)[]): this;
  transmit<O>(output: AbstractState<O>, reducer: (value: T, state: O) => O): this;
  transmit<O>(output: EmitterOrSubject<O>, reducer: (value: T) => O): this;
  effect(...operators: OperatorFunction<any, any>[]): this;
  tap(observer: Partial<Observer<T>>): this;
  tap(next: (value: T) => void): this;
}
```

## Example

```ts copy
import {state} from '@bitfiber/rx';

// Creates a state
const counter = state<number>(1);
```
