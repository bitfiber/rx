import {Badge} from '../../../';

# Store <Badge type={'class'}>Class</Badge> <Badge type={'modifier'}>Abstract</Badge>

The `Store` class is a foundational component for implementing reactive state management and
handling asynchronous data flow in modules or entire applications. It serves as a central hub,
organizing and managing store items like emitters, states, and groups, ensuring seamless
interaction among them.

Stores can also include methods to trigger specific actions, making them a powerful and
flexible tool for coordinating complex application logic. Their structured design simplifies
the development of scalable, maintainable, and reactive applications, ensuring consistency and
clarity in managing state and data flow.

By implementing the `StoreHooks` interface, the store provides lifecycle hooks for executing custom
logic before and after key events, such as store initialization and completion.

The `Store` class is an abstract foundation designed to serve as a base for specific store
implementations that define concrete collections of store items

See also: [StoreHooks](/store/reference/storeHooks)

## API

```ts copy
abstract class Store extends AbstractItem implements StoreHooks {
  initialize(beforeInit?: (store: this) => void): this;
  complete(): void;
  protected markAsReady(): void;
}
```

## Example

```ts copy filename="products.store.ts"
import {switchMap} from 'rxjs';
import {Store, asyncGroup, emitter, state, transmit} from '@bitfiber/rx';

interface Product {
  id: number;
  name: string;
  price: number;
}

interface ProductCategory {
  id: number;
  name: string;
}

interface ProductsFilters {
  search: string;
  page: number;
}

interface ProductsState {
  categories: ProductCategory[];
  products: Product[];
}

class ProductsStore extends Store {
  // Provides the start of the first data loading process
  start = emitter<void>();

  // Provides the state of the products filters
  filters = state<ProductsFilters>({search: '', page: 1})
    .useLazyEmission();
  
  // Provides an async group for managing categories loading process
  categoriesReq = asyncGroup<void, ProductCategory[], Error>((categoriesReq, {launch}) => {
    launch
      // Trigger categories loading once the start emitter emits
      .wait(this.start)
      // Define a side effect for loading categories
      .effect(switchMap(() => categoriesService.get().pipe(transmit(categoriesReq))));
  }, []);
  
  // Provides an async group for managing products loading process
  productsReq = asyncGroup<ProductsFilters, Product[], Error>((productsReq, {launch}) => {
    launch
      // Trigger products loading after categories are successfully loaded
      .wait(this.categoriesReq.success, () => this.filters())
      // Reload products when filters are updated
      .receive(this.filters)
      // Define a side effect for loading products
      .effect(switchMap(filters => productsService.get(filters).pipe(transmit(productsReq))));
  }, []);
  
  // Provides the loading status state
  isLoading = state<boolean>(false, s => s
    // Track loading status based on the state of asynchronous actions
    .select(
      this.categoriesReq.state,
      this.productsReq.state,
      (categoriesState, productsState) => categoriesState.inProgress || productsState.inProgress,
    ),
  );

  // Provides the main store state
  data = state<ProductsState>({categories: [], products: []}, s => s
    // Combine data from categories and products into a single state
    .select(
      this.categoriesReq.success,
      this.productsReq.success,
      (categories, products) => ({categories, products}),
    ),
  );

  // Provides the store error handling
  errors = emitter<Error>(e => e
    // Collect errors from asynchronous actions
    .receive(this.categoriesReq.fail, this.productsReq.fail)
    // Handle errors with a side effect
    .tap(error => console.log('Error:', error)));

  // Marks the store as ready, indicating that all store items have been defined
  #ready = this.markAsReady();
  
  // Automatically start the store after initialization
  afterStoreInit(): void {
    this.start.emit();
  }
  
  // Changes the filters applied to the products
  updateFilters(filters: Partial<ProductsFilters>): void {
    this.filters.update(state => ({...state, ...filters}));
  }
}

// Using the store:

// Create a new store for managing products
const productsStore = new ProductsStore();

// Initialize the store and all its items
productsStore.initialize();

// Use tap to perform a side effect when the loading status changes
productsStore.isLoading
  .tap(isLoading => console.log('Loading state:', isLoading));

// Subscribe to the state observable to react to data updates
productsStore.data.$
  .subscribe(data => console.log('Updated products:', data.products));

// Update filters to trigger products reloading
productsStore.updateFilters({page: 2});

// Retrieve the current data synchronously
const data = productsStore.data();
console.log('Current products:', data.products);

// Complete the store and all its items when done
productsStore.complete();
```
