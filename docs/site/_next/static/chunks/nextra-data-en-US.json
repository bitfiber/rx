{"/about":{"title":"About Bitfiber Rx","data":{"":"Bitfiber Rx was initially created by Oleksandr Zmanovskyi in 2023.","team#Team":"Currently, the project is maintained by Oleksandr Zmanovskyi.\nYou can check out the full list of contributors on GitHub.","credits#Credits":"Bitfiber Rx is powered by these incredible open source projects:\nRxJS\nNextra","contributing#Contributing":"We welcome contributions from the community. Before contributing, please take the time to read\nour contributing guide to familiarize yourself with our\ncontribution process.\nThis guide can help you understand our expectations and save you time in the long run.","support#Support":"Have questions, encountered problems, or want to request new features?\nFeel free to start a discussion in our community forum.\nYour feedback is valuable to us!","found-an-issue-or-bug#Found an Issue or Bug?":"If you've found a bug or issue, please report it using GitHub Issues.\nYour reports help us improve the project for everyone.","code-of-conduct#Code of Conduct":"This project adheres to the Code of Conduct to ensure\na welcoming and inclusive community for all participants.\nBy participating, you are expected to uphold this code.","license#License":"Code licensed under an Apache 2.0 License.\nDocumentation licensed under CC BY 4.0.\nCopyright © 2023-2025 Oleksandr Zmanovskyi. All rights reserved."}},"/installation":{"title":"Installation","data":{"installing-with-npm#Installing with npm":"For more information on using npm check out the docs here","installing-with-yarn#Installing with yarn":"For more information on using yarn check out the docs here"}},"/operators":{"title":"What is RxJS Operators?","data":{"":"An Operator is essentially a pure function which takes one Observable as input and generates another\nObservable as output. Subscribing to the output Observable will also subscribe to the input\nObservable.Operators can be piped to Observables using the syntax observableInstance.pipe(operator) or,\nmore commonly, observableInstance.pipe(operatorFactory()).","list-of-operators#List of Operators":"completeWith\nCompletes the subscriber when the provided trigger observable completes\nstartWithDefined\nInstantly emits a value from the provided getter if the value is defined\ntransmit\nTransmits the result of the asynchronous action to the provided emitter or group, allowing success,\nfailure, and completion actions or effects to be performed. Only for Rx Store","creating-a-custom-operator#Creating a Custom Operator":"For creating a custom RxJS operator, you can use the operator method.\nIt provides the source observable and the subscriber as arguments in a callback function, making it\neasier to define custom transformations or logic","custom-operator-example#Custom Operator Example":""}},"/operators/reference/operator":{"title":"operator Function","data":{"":"Creates a custom RxJS operator that can be used in the pipe function of an observable.\nThis operator allows you to apply custom transformation logic to the observable stream@template T \nThe type of values emitted by the source observable@template R \nThe type of values emitted by the transformed observable after applying the operator@param fn: (source: Observable<T>, subscriber: Subscriber<R>) => Subscription | void \nA function that takes the source observable and the subscriber, and returns teardown logic to\nclean up resources when the observable completes or errors@returns OperatorFunction<T, R>","api#API":"","example#Example":""}},"/operators/reference/completeWith":{"title":"completeWith Function","data":{"":"Returns an RxJS operator that completes the subscriber when the provided trigger observable\ncompletes. Optionally, if withError is set to true, the subscriber will also complete\nif the trigger observable errors@template T \nThe type of values emitted by the source observable@param trigger: Observable<any> \nAn observable that can trigger the completion of the subscriber@param withError?: boolean \nIf true, the subscriber will also complete when the trigger errors@returns OperatorFunction<T, T>","api#API":"","example#Example":""}},"/sources":{"title":"What is Data Sources?","data":{"":"Data sources act as facades for specific parts of data in external storages like local storage,\nsession storage, cookies, and more. They implement a unified interface called DataSource,\nwhich simplifies integration with various storage mechanisms. This interface also enables states to\nseamlessly connect to external storages, ensuring that state remains synchronized with them.Beyond providing access to a specific portion of the storage, data sources enable the ability to\nsubscribe to data changes. This feature ensures reactive updates within your application, keeping\nyour state aligned with external changes.","list-of-data-sources#List of Data Sources":"Local Storage Part\nProvides interaction with a specific key-value pair stored in the browser's local storage\nSession Storage Part\nProvides interaction with a specific key-value pair stored in the browser's session storage\nMemory Storage Part\nProvides interaction with a specific key-value pair stored in the memory storage\nCookie Part\nProvides interaction with a specific key-value pair stored in the browser's cookie","how-to-use-data-sources#How to Use Data Sources":"","create-a-data-source#Create a data source":"Let’s start by creating a data source that manages data in localStorage under the key theme:","modify-data#Modify data":"Use the data source to set or update the value:\nTo remove the value, simply call:","retrieve-data#Retrieve data":"Retrieve the current value:","subscribe-to-data-changes#Subscribe to data changes":"Data sources are reactive, meaning you can subscribe to data changes and respond accordingly:","any-data-types-for-storages#Any Data Types for Storages":"Data sources such as localStoragePart, sessionStoragePart, and cookiePart simplify\nthe handling of data by allowing you to store and retrieve values of any type, including objects,\narrays, and primitives. These sources automatically convert data into JSON strings when storing it\nand parse JSON strings back into their original types when retrieving.","using-data-sources-with-state#Using Data Sources with State":"The DataSource interface facilitates seamless connection of\nreactive state to specific parts of external storages, ensuring that\nstate data remains synchronized and up to date. This approach streamlines the management of data\nconsistency and alignment across your application.","key-benefits#Key Benefits":"Seamless Synchronization:\nAutomatically sync state updates to external storage and vice versa, ensuring consistent data\nacross your application.\nReactive Updates:\nSubscribe to changes in external storages and propagate those changes directly to your state,\nenabling real-time reactivity.\nScoped Access:\nFocus on specific parts of storage, allowing precise and efficient management of data segments.","state-connection-example#State Connection Example":"","creating-a-custom-data-source#Creating a Custom Data Source":"To create a custom data source, you need to implement the DataSource\ninterface. This allows your custom data source to integrate seamlessly with states","custom-data-source-example#Custom Data Source Example":""}},"/sources/reference":{"title":"Reference","data":{"common#Common":"","local-storage#Local Storage":"","session-storage#Session Storage":"","memory-storage#Memory Storage":"","cookie#Cookie":""}},"/sources/reference/cookie":{"title":"Cookie Class","data":{"":"Provides access to browser cookies as a key-value storage.\nThe Cookie class implements the KeyValueSource interface, allowing interaction with\nbrowser cookies using key-value semantics. It provides methods for retrieving, setting,\nobserving, and removing cookies@template T = any \nRepresents an object that includes both the value and parameters for the cookie.\nDefaults to CookieData<string | undefined>See also: KeyValueSource, CookieData, CookieParams","api#API":"","example#Example":""}},"/operators/reference/startWithDefined":{"title":"startWithDefined Function","data":{"":"Instantly emits a value from the provided getter if the value is defined.\nIf the getter returns an observable, the value will be emitted when the observable emits, but only\nif no values have been emitted previously. Optionally, if nonNullish is set to true, null or\nundefined values will not be emitted@template T \nThe type of the values emitted by the observable@template U \nA subtype of T representing the specific value type emitted@param getter: () => U | Observable<U> \nA function that returns an initial value or an observable that emits the initial value@param nonNullish?: boolean \nIf true, null or undefined values will not be emitted@returns OperatorFunction<T, T>","api#API":"","example#Example":""}},"/operators/reference":{"title":"Reference","data":{}},"/sources/reference/cookieFn":{"title":"cookie Function","data":{"":"Creates and returns a singleton instance of the Cookie class and ensures that only one instance\nis created. If the instance already exists, it returns the existing one@template T extends CookieData<any> = CookieData<string | undefined> \nRepresents an object that includes both the value and parameters for the cookie.\nDefaults to CookieData<string | undefined>@returns Cookie<T> See also: Cookie, CookieData","api#API":"","example#Example":""}},"/sources/reference/cookieParams/expires":{"title":"expires Property Optional","data":{"":"Specifies the expiration date for the cookie. If not set, the cookie is considered a session cookie","api#API":"","example#Example":""}},"/sources/reference/cookieParams":{"title":"CookieParams Interface","data":{"":"Represents the optional parameters that can be used when setting a cookie","api#API":"","example#Example":""}},"/sources/reference/cookieParams/sameSite":{"title":"sameSite Property Optional","data":{"":"Specifies the SameSite policy for the cookie, which controls how cookies are sent with\ncross-site requests","api#API":"","example#Example":""}},"/sources/reference/cookieParams/path":{"title":"path Property Optional","data":{"":"Specifies the URL path that must exist in the requested URL for the cookie to be valid","api#API":"","example#Example":""}},"/sources/reference/cookieData":{"title":"CookieData Type","data":{"":"Combines cookie parameters with the value to be stored in a cookie@template T \nThe type of the value stored in the cookieSee also: CookieParams","api#API":"","example#Example":""}},"/sources/reference/cookieParams/domain":{"title":"domain Property Optional","data":{"":"Specifies the domain for which the cookie is valid","api#API":"","example#Example":""}},"/sources/reference/cookiePart":{"title":"CookiePart Class","data":{"":"Extends KeyValueSourcePart and allows interaction with a particular key in the browser's cookie\nstorage. It provides methods for retrieving, setting, and observing the cookie value associated\nwith the given key@template T extends CookieData<any> = CookieData<string | undefined> \nRepresents an object that includes both the value and parameters for the cookie.\nDefaults to CookieData<string | undefined>See also: KeyValueSourcePart, CookieData, CookieParams","api#API":"","example#Example":""}},"/sources/reference/cookieParams/maxAge":{"title":"maxAge Property Optional","data":{"":"Specifies the maximum age of the cookie in seconds. Overrides expires if both are set","api#API":"","example#Example":""}},"/sources/reference/cookieParams/secure":{"title":"secure Property Optional","data":{"":"Indicates whether the cookie should only be sent over secure protocols like HTTPS","api#API":"","example#Example":""}},"/sources/reference/cookiePart/$":{"title":"$ Property Readonly","data":{"":"Allows subscribers to reactively observe value changes","api#API":"","example#Example":""}},"/sources/reference/cookiePartFn":{"title":"cookiePart Function","data":{"":"Creates an instance of CookiePart, allowing interaction with a specific key-value pair stored\nin the browser's cookie. You can also provide optional removeParams for managing cookie removal@template T extends CookieData<any> = CookieData<string | undefined> \nRepresents an object that includes both the value and parameters for the cookie.\nDefaults to CookieData<string | undefined>@param key: string \nThe key used to access the value in the browser cookie@param removeParams?: CookieParams \nOptional parameters for managing cookie removal@returns CookiePart<T> See also: CookiePart, CookieData, CookieParams","api#API":"","example#Example":""}},"/sources/reference/cookiePart/remove":{"title":"remove Method","data":{"":"Removes the current value","api#API":"","example#Example":""}},"/sources/reference/cookiePart/get":{"title":"get Method","data":{"":"Retrieves the current value@returns T","api#API":"","example#Example":""}},"/sources/keyValueSources":{"title":"What is Key-Value Sources?","data":{"":"Key-value sources act as facades for external storages like local storage, session storage,\ncookies, and more. They implement a unified interface called KeyValueSource,\nwhich simplifies integration with various storage mechanisms.In addition to storage access, key-value sources provide the ability to subscribe to data changes\nin external storages, enabling reactive updates within your application.","list-of-key-value-sources#List of Key-Value Sources":"Local Storage\nProvides interaction with the browser's local storage\nSession Storage\nProvides interaction with the browser's session storage\nMemory Storage\nProvides interaction the memory storage\nCookie\nProvides interaction with the browser's cookie","how-to-use-key-value-sources#How to Use Key-Value Sources":"","create-a-key-value-source#Create a key-value source":"Let’s start by creating a key-value source that manages data in localStorage:","modify-data#Modify data":"Set or update the value for a specific key:\nTo remove the value for a key, use:","retrieve-data#Retrieve data":"Retrieve the current value for a key:","subscribe-to-data-changes#Subscribe to data changes":"Key-value sources are reactive, meaning you can subscribe to changes for a specific key and\nrespond accordingly:","any-data-types-for-storages#Any Data Types for Storages":"Key-value sources such as localStorage, sessionStorage, and cookie simplify the handling of\ndata by allowing you to store and retrieve values of any type, including objects, arrays, and\nprimitives. These sources automatically convert data into JSON strings when storing it and parse\nJSON strings back into their original types when retrieving."}},"/sources/reference/cookie/destroy":{"title":"destroy Method","data":{"":"Destroys the reference to the instance and frees any associated resources","api#API":"","example#Example":""}},"/sources/reference/cookiePart/set":{"title":"set Method","data":{"":"Sets a new value@param value: T \nA new form value","api#API":"","example#Example":""}},"/sources/reference/cookie/observe":{"title":"observe Method","data":{"":"Returns an observable that emits value changes of the cookie associated with the specified key@param key: string \nThe specific key under which the cookie value is stored@returns Observable<T> \nAn observable that will emit value changes for a specific key","api#API":"","example#Example":""}},"/sources/reference/cookie/get":{"title":"get Method","data":{"":"Returns the value of the cookie associated with the given key and parses it as JSON. If the cookie\ndoes not exist, returns undefined@param key: string \nThe specific key under which the cookie value is stored@returns T","api#API":"","example#Example":""}},"/sources/reference/cookie/remove":{"title":"remove Method","data":{"":"Removes the cookie associated with the given key. Optionally, you can provide CookieParams to\nspecify additional options, such as the path or domain, to ensure the correct cookie is removed@param key: string \nThe specific key of the cookie to be removed@param params?: CookieParams \nOptional parameters that can be used to specify the cookie's path, domain, etc.See also: CookieParams","api#API":"","example#Example":""}},"/sources/reference/dataSource":{"title":"DataSource Interface","data":{"":"Represents a data source that can be observed, retrieved, modified, or removed.\nIt provides an observable for monitoring changes@template T \nThe type of data stored in the data source","api#API":"","example#Example":""}},"/sources/reference/dataSource/get":{"title":"get Method","data":{"":"Retrieves the current value from the data source@returns T \nThe data source value","api#API":"","example#Example":""}},"/sources/reference/dataSource/$":{"title":"$ Property","data":{"":"An observable that allows subscribers to reactively observe changes or updates to the data","api#API":"","example#Example":""}},"/sources/reference/cookie/set":{"title":"set Method","data":{"":"Sets a cookie with the specified key and value, stringified before being added to the cookie.\nAdditional parameters, such as cookie options (e.g., expires, path), can be provided as part\nof the data object@param key: string \nThe specific key under which the value will be stored@param value: T \nAn object containing the new value to store, as well as optional cookie parametersSee also: CookieData","api#API":"","example#Example":""}},"/sources/reference/dataSource/remove":{"title":"remove Method","data":{"":"Removes the current value from the data source","api#API":"","example#Example":""}},"/sources/reference/keyValueSource":{"title":"KeyValueSource Interface","data":{"":"Represents a generic, writable key-value source with methods for getting, setting, removing, and\nobserving values associated with a specific key. It also includes a method to destroy the source,\nallowing for cleanup when it is no longer needed@template T = any \nThe type of the values stored in the key-value source. Defaults to any","api#API":"","example#Example":""}},"/sources/reference/dataSource/set":{"title":"set Method","data":{"":"Sets a new value for the data source.\nThis method updates the value in the data source and notifies observers of the change@param value: T \nThe new value to be set for the data source","api#API":"","example#Example":""}},"/sources/reference/keyValueSourcePart/get":{"title":"get Method","data":{"":"Retrieves the current value@returns T","api#API":"","example#Example":""}},"/sources/reference/keyValueSourcePart":{"title":"KeyValueSourcePart Class","data":{"":"Implements the DataSource interface and provides functionality for managing a specific portion\nof a key-value source. It allows observing, retrieving, setting, and removing data associated\nwith a particular key@template T \nThe type of data stored in the key-value sourceSee also: DataSource, KeyValueSource","api#API":"","example#Example":""}},"/sources/reference/keyValueSourcePart/remove":{"title":"remove Method","data":{"":"Removes the current value","api#API":"","example#Example":""}},"/sources/reference/keyValueSource/get":{"title":"get Method","data":{"":"Retrieves the value associated with the specified key@param key: string \nThe key for which to retrieve the value@returns T","api#API":"","example#Example":""}},"/sources/reference/keyValueSourcePart/set":{"title":"set Method","data":{"":"Sets a new value@param value: T \nA new form value","api#API":"","example#Example":""}},"/sources/reference/keyValueSource/destroy":{"title":"destroy Method","data":{"":"Destroys the key-value source, releasing any resources held by it","api#API":"","example#Example":""}},"/sources/reference/keyValueSource/remove":{"title":"remove Method","data":{"":"Removes the value associated with the specified key@param key: string \nThe key for which to remove the value","api#API":"","example#Example":""}},"/sources/reference/keyValueSource/observe":{"title":"observe Method","data":{"":"Returns an observable that will emit value changes for a specific key@param key: string \nThe key for which to observe value changes@returns Observable<T> \nAn observable that will emit value changes for a specific key","api#API":"","example#Example":""}},"/sources/reference/keyValueSource/set":{"title":"set Method","data":{"":"Sets a value for the specified key@param key: string \nThe key to associate the value with@param value: T \nThe value to be set for the key","api#API":"","example#Example":""}},"/sources/reference/localStorage":{"title":"LocalStorage Class","data":{"":"Implements the KeyValueSource interface, allowing interaction with the browser's local storage\nusing key-value semantics. It provides methods for retrieving, setting, observing, and removing\nkey-value pairs stored in local storage@template T = any \nThe type of the value stored in local storage. Defaults to anySee also: KeyValueSource","api#API":"","example#Example":""}},"/sources/reference/localStorageFn":{"title":"localStorage Function","data":{"":"Creates a singleton instance of LocalStorage and ensures that only one instance is created.\nIf the instance already exists, it returns the existing instance@template T = any \nThe type of the value stored in local storage. Defaults to any@returns LocalStorage<T> See also: LocalStorage","api#API":"","example#Example":""}},"/sources/reference/localStoragePart/$":{"title":"$ Property Readonly","data":{"":"Allows subscribers to reactively observe value changes","api#API":"","example#Example":""}},"/sources/reference/localStoragePart":{"title":"LocalStoragePart Class","data":{"":"Extends KeyValueSourcePart and allows interaction with a particular key in the browser's\nlocal storage. It provides methods for retrieving, setting, and observing the value associated\nwith the given key@template T = string | undefined \nThe type of the value stored in local storage. Defaults to string | undefinedSee also: KeyValueSourcePart","api#API":"","example#Example":""}},"/sources/reference/localStoragePartFn":{"title":"localStoragePart Function","data":{"":"Creates an instance of LocalStoragePart, allowing interaction with a specific key-value pair\nstored in the browser's local storage@template T = string | undefined \nThe type of the value stored in local storage. Defaults to string | undefined@param key: string \nThe key used to access the value in local storage@returns LocalStoragePart<T> See also: LocalStoragePart","api#API":"","example#Example":""}},"/sources/reference/localStoragePart/get":{"title":"get Method","data":{"":"Retrieves the current value@returns T","api#API":"","example#Example":""}},"/sources/reference/keyValueSourcePart/$":{"title":"$ Property Readonly","data":{"":"Allows subscribers to reactively observe value changes","api#API":"","example#Example":""}},"/sources/reference/localStoragePart/remove":{"title":"remove Method","data":{"":"Removes the current value","api#API":"","example#Example":""}},"/sources/reference/localStorage/remove":{"title":"remove Method","data":{"":"Removes a value associated with the provided key from local storage@param key: string \nThe specific key under which the value is stored and should be removed","api#API":"","example#Example":""}},"/sources/reference/localStoragePart/set":{"title":"set Method","data":{"":"Sets a new value@param value: T \nA new form value","api#API":"","example#Example":""}},"/sources/reference/localStorage/observe":{"title":"observe Method","data":{"":"Returns an observable that emits value changes stored under the given key in local storage@param key: string \nThe specific key under which the value is stored in local storage@returns Observable<T> \nAn observable that will emit value changes for a specific key","api#API":"","example#Example":""}},"/sources/reference/localStorage/get":{"title":"get Method","data":{"":"Retrieves a value stored under the given key in local storage.\nThe retrieved value is parsed from its JSON string format into the expected type T.\nIf the key does not exist or if parsing fails, returns 'undefined'@param key: string \nThe specific key under which the value is stored in local storage@returns T","api#API":"","example#Example":""}},"/sources/reference/localStorage/set":{"title":"set Method","data":{"":"Sets a new value under the given key in local storage.\nBefore storing, the value is serialized to a JSON string format@param key: string \nThe specific key under which the value will be stored@param value: T \nThe new value to be stored, which will be stringified before being added","api#API":"","example#Example":""}},"/sources/reference/localStorage/destroy":{"title":"destroy Method","data":{"":"Destroys the reference to the instance and frees any associated resources","api#API":"","example#Example":""}},"/sources/reference/memoryStoragePart":{"title":"MemoryStoragePart Class","data":{"":"Extends KeyValueSourcePart and allows interacting with the data stored under a specific key in\nthe memory storage. It enables retrieving, setting, observing, and removing data associated with\nthe specified key@template T = string | undefined \nThe type of data stored under the specific key. Defaults to string | undefinedSee also: KeyValueSourcePart","api#API":"","example#Example":""}},"/sources/reference/memoryStorageFn":{"title":"memoryStorage Function","data":{"":"Creates a singleton instance of MemoryStorage, ensuring that only one instance of the in-memory\nkey-value storage exists@template T = any \nThe type of data stored in the memory storage. Defaults to any@returns MemoryStorage<T> See also: MemoryStorage","api#API":"","example#Example":""}},"/sources/reference/memoryStoragePartFn":{"title":"memoryStoragePart Function","data":{"":"Creates an instance of MemoryStoragePart, allowing interaction with a specific key-value pair\nstored in the memory storage@template T = string | undefined \nThe type of data stored under the specific key. Defaults to string | undefined@param key: string \nThe key that is used to access the value in the memory storage@returns MemoryStoragePart<T> See also: MemoryStoragePart","api#API":"","example#Example":""}},"/sources/reference/memoryStoragePart/$":{"title":"$ Property Readonly","data":{"":"Allows subscribers to reactively observe value changes","api#API":"","example#Example":""}},"/sources/reference/memoryStorage/destroy":{"title":"destroy Method","data":{"":"Destroys the memory storage, releasing all stored key-value pairs","api#API":"","example#Example":""}},"/sources/reference/memoryStoragePart/set":{"title":"set Method","data":{"":"Sets a new value@param value: T \nA new form value","api#API":"","example#Example":""}},"/sources/reference/memoryStoragePart/remove":{"title":"remove Method","data":{"":"Removes the current value","api#API":"","example#Example":""}},"/sources/reference/memoryStorage/get":{"title":"get Method","data":{"":"Retrieves the value associated with the specified key@param key: string \nThe key for which to retrieve the value@returns T","api#API":"","example#Example":""}},"/sources/reference/memoryStorage/observe":{"title":"observe Method","data":{"":"Returns an observable that will emit value changes for a specific key@param key: string \nThe key for which to observe value changes@returns Observable<T> \nAn observable that will emit value changes for a specific key","api#API":"","example#Example":""}},"/sources/reference/memoryStoragePart/get":{"title":"get Method","data":{"":"Retrieves the current value@returns T","api#API":"","example#Example":""}},"/sources/reference/memoryStorage/remove":{"title":"remove Method","data":{"":"Removes the value associated with the specified key@param key: string \nThe key for which to remove the value","api#API":"","example#Example":""}},"/sources/reference/sessionStorageFn":{"title":"sessionStorage Function","data":{"":"Creates and returns a singleton instance of SessionStorage and ensures that only one instance\nis created. If the instance already exists, it returns the existing instance@template T = any \nThe type of the value stored in session storage. Defaults to any@returns SessionStorage<T> See also: SessionStorage","api#API":"","example#Example":""}},"/sources/reference/sessionStorage":{"title":"SessionStorage Class","data":{"":"Implements the KeyValueSource interface, allowing interaction with the browser's session storage\nusing key-value semantics. It provides methods for retrieving, setting, observing, and removing\nkey-value pairs stored in session storage@template T = any \nThe type of the value stored in session storage. Defaults to anySee also: KeyValueSource","api#API":"","example#Example":""}},"/sources/reference/memoryStorage/set":{"title":"set Method","data":{"":"Sets a value for the specified key@param key: string \nThe key to associate the value with@param value: T \nThe value to be set for the key","api#API":"","example#Example":""}},"/sources/reference/sessionStoragePart":{"title":"SessionStoragePart Class","data":{"":"Extends KeyValueSourcePart and allows interaction with a particular key in the browser's\nsession storage. It provides methods for retrieving, setting, and observing the value associated\nwith the given key@template T = string | undefined \nThe type of the value stored in session storage. Defaults to string | undefinedSee also: KeyValueSourcePart","api#API":"","example#Example":""}},"/sources/reference/sessionStoragePart/get":{"title":"get Method","data":{"":"Retrieves the current value@returns T","api#API":"","example#Example":""}},"/sources/reference/sessionStoragePartFn":{"title":"sessionStoragePart Function","data":{"":"Creates an instance of SessionStoragePart, allowing interaction with a specific key-value pair\nstored in the browser's session storage@template T = string | undefined \nThe type of the value stored in session storage. Defaults to string | undefined@param key: string \nThe key used to access the value in session storage@returns SessionStoragePart<T> See also: SessionStoragePart","api#API":"","example#Example":""}},"/sources/reference/sessionStoragePart/remove":{"title":"remove Method","data":{"":"Removes the current value","api#API":"","example#Example":""}},"/sources/reference/sessionStoragePart/$":{"title":"$ Property Readonly","data":{"":"Allows subscribers to reactively observe value changes","api#API":"","example#Example":""}},"/sources/reference/sessionStoragePart/set":{"title":"set Method","data":{"":"Sets a new value@param value: T \nA new form value","api#API":"","example#Example":""}},"/sources/reference/sessionStorage/destroy":{"title":"destroy Method","data":{"":"Destroys the reference to the instance and frees any associated resources","api#API":"","example#Example":""}},"/sources/reference/sessionStorage/observe":{"title":"observe Method","data":{"":"Returns an observable that emits value changes stored under the given key in session storage@param key: string \nThe specific key under which the value is stored in session storage@returns Observable<T> \nAn observable that will emit value changes for a specific key","api#API":"","example#Example":""}},"/sources/reference/sessionStorage/remove":{"title":"remove Method","data":{"":"Removes a value associated with the provided key from session storage@param key: string \nThe specific key under which the value is stored and should be removed","api#API":"","example#Example":""}},"/sources/reference/sessionStorage/get":{"title":"get Method","data":{"":"Retrieves a value stored under the given key in session storage.\nThe retrieved value is parsed from its JSON string format into the expected type T.\nIf the key does not exist or if parsing fails, returns 'undefined'@param key: string \nThe specific key under which the value is stored in session storage@returns T","api#API":"","example#Example":""}},"/sources/reference/sessionStorage/set":{"title":"set Method","data":{"":"Sets a new value under the given key in session storage.\nBefore storing, the value is serialized to a JSON string format@param key: string \nThe specific key under which the value will be stored@param value: T \nThe new value to be stored, which will be stringified before being added","api#API":"","example#Example":""}},"/store/emitters":{"title":"Emitters","data":{"":"Emitters are fundamental units of communication in the reactive store. They enable straightforward\ncreation and management of reactive streams, integrating seamlessly with other reactive sources\nlike emitters, states, and observables. This integration allows you to build complex networks of\nstreams and effectively manage reactive data flows.","creating-an-emitter#Creating an Emitter":"","basic-emitter#Basic Emitter":"To create Emitter, use the emitter function:","emitter-with-interaction-logic#Emitter with Interaction Logic":"To add interaction logic with other reactive sources, use the onInit callback. This ensures\nsubscriptions and emissions occur only after the store is initialized:","emitting-data#Emitting Data":"Emitters allow you to send data to their subscribers, effects, and any connected reactive sources\nusing the emit method:","receiving-data#Receiving Data":"Emitters can receive data from various reactive sources like emitters, states, and observables,\ntransmitting it to subscribers without storing the data.","methods-for-receiving-data#Methods for Receiving Data":"receive method\nEmitters can receive data from other reactive sources using the receive method.Without Data Transformation\nWith Data Transformation\nselect method\nCombines data from all sources and emits a computed value whenever any source emits:\nzip method\nCombines data from all sources, emitting only when all sources emit new values:\nwait method\nWaits for the first values from all sources, emits a computed value, and completes the stream:","working-with-observables#Working with Observables":"Emitters can receive data from observables, which allows you to use RxJS operators for more\nadvanced stream manipulation before connecting them to emitters.","transmitting-data#Transmitting Data":"Emitters can transmit their emitted values to other reactive sources using\nthe transmit method.","without-data-transformation#Without Data Transformation":"","with-data-transformation#With Data Transformation":"","creating-side-effects#Creating Side Effects":"Emitters support creating side effects using tap and\neffect methods.","using-tap#Using Tap":"The tap method performs a side effect whenever the emitter emits a value.","using-effect#Using Effect":"The effect method allows for complex stream management using RxJS operators.","managing-all-streams#Managing All Streams":"Emitters allow you to apply RxJS operators across all their streams simultaneously using\nthe manage method. This ensures consistent stream behavior\nby applying the same operators to all streams generated by the emitter."}},"/store/reference/asyncGroup":{"title":"AsyncGroup Class","data":{"":"Represents an asynchronous group that manages the lifecycle of an asynchronous action,\nproviding emitters for launching actions, handling success, dealing with failures, and\nmanaging the state of these actions.The AsyncGroup class extends AbstractAsyncGroup and is designed to facilitate the management\nof asynchronous actions. This structure allows for organized and efficient management\nof complex asynchronous workflows@template L \nThe type representing the data for the launch emitter@template S \nThe type representing the data for the success emitter@template F \nThe type representing the error data for the fail emitter","api#API":"","example#Example":""}},"/store/reference":{"title":"Reference","data":{"store#Store":"","emitter#Emitter":"","state#State":"","group#Group":"","named-group#Named Group":"","async-group#Async Group":"","operator-transmit#Operator Transmit":""}},"/store/groups":{"title":"Groups","data":{"":"Groups are collections of emitters, states, and other groups that are unified under a specific\nfeature. They help organize related reactive sources into a cohesive structure, ensuring proper\ninitialization and completion of all items as a single unit.","list-of-groups#List of Groups":"","group#Group":"The group collects all subsequently created emitters, states, and groups until\ngroup.markAsReady() is called.The group can be used as an alternative to the store when lifecycle hooks are not required, or\nwhen extending the Store class is not feasible due to other class inheritance.","named-group#Named Group":"The named group extracts emitters, states, and groups from the provided object and adds them to\nthe group. Each item is accessible by the key used in the object.","async-group#Async Group":"The async group manages the lifecycle of asynchronous actions, providing emitters for launching\nactions, handling success, dealing with failures, and managing the state of these actions.","creating-a-custom-group#Creating a Custom Group":"To create a custom group, extend the AbstractGroup class:","adding-group-items#Adding Group Items":"Within the group class, define the group items you need, such as emitters, states, or groups:","marking-group-as-ready#Marking Group as Ready":"To finalize the group setup and indicate that all group items have been defined,call\nthe markAsReady method:","adding-interaction-logic#Adding Interaction Logic":"Use the executeInnerDeferredActions method to add interaction logic:","adding-factory-function#Adding Factory Function":"To maintain a consistent style in group implementations, define a factory function for creating\nthe group. This approach provides a standardized way to initialize groups and optionally apply\nadditional setup logic:","usage-the-group#Usage the group":"Create and initialize the group using the factory function:"}},"/store/reference/asyncGroupFn":{"title":"asyncGroup Function","data":{"":"Creates a new AsyncGroup instance that manages the lifecycle of an asynchronous action,\nproviding emitters for launching actions, handling success, dealing with failures, and\nmanaging the state of these actions.This function also allows for an optional onInit callback, which can be used to perform\nadditional setup or configuration just before the group initialization.The fallback value is used as a default success value in case the asynchronous action fails,\nensuring that the success emitter always returns a value@template L \nThe type representing the data for the launch emitter@template S \nThe type representing the data for the success emitter@template F \nThe type representing the error data for the fail emitter@param onInit?: (group: AsyncGroup<L, S, F>, sameGroup: AsyncGroup<L, S, F>) => void \nAn optional callback function executed just before the group initialization@param fallbackValue?: S \nAn optional fallback value of type S that will be used as the default success value if\nthe asynchronous action fails@returns AsyncGroup<L, S, F> See also: AsyncGroup, transmit","api#API":"","example#Example":""}},"/store/reference/asyncGroup/complete":{"title":"complete Method","data":{"":"Completes the group and all its items, signaling to all item subscribers that no more values\nwill be emitted.Once the group is completed, Its items will no longer emit any values, and any subsequent\nsubscriptions will immediately receive an error.In most cases, this method will be called automatically by a group or store managing the group,\nso you generally don't need to call it manually unless you have a specific reason to do so","api#API":"","example#Example":""}},"/store":{"title":"What is Store?","data":{"":"The Store is a foundational component for implementing reactive state management and\nhandling asynchronous data flow in modules or entire applications. It serves as a central hub,\norganizing and managing store items like emitters, states, and groups, ensuring seamless\ninteraction among them.Stores can also include methods to trigger specific actions, making them a powerful and\nflexible tool for coordinating complex application logic. Their structured design simplifies\nthe development of scalable, maintainable, and reactive applications, ensuring consistency and\nclarity in managing state and data flow.","creating-a-store#Creating a Store":"To create a store, define a new class that extends the Store class.","adding-store-items#Adding Store Items":"Within the store class, define the store items you need, such as emitters, states, or groups.\nEach item will serve a specific purpose in managing the store's reactive logic and state.","adding-interaction-logic#Adding Interaction Logic":"Use onInit callbacks within emitters, states, and groups to define side effects, establish\nrelationships between store items, and manage their interactions effectively. This ensures\nsubscriptions and emissions occur only after the store is initialized.","marking-store-as-ready#Marking Store as Ready":"To finalize the store setup and indicate that all store items have been defined, call\nthe markAsReady method.","lifecycle-hooks#Lifecycle Hooks":"You can use lifecycle hooks like beforeStoreInit, afterStoreInit, beforeStoreComplete, and\nafterStoreComplete to add custom logic at key lifecycle events.","action-methods#Action Methods":"Define action methods to trigger specific store logic.","full-store-example#Full Store Example":"Below is a complete example of a reactive store for managing products, categories, and filters.","usage-the-store#Usage the store":"To use the store, create an instance, initialize it, and then interact with its items:"}},"/store/reference/asyncGroup/finish":{"title":"finish Property Readonly","data":{"":"An emitter that triggers when the asynchronous action's entire lifecycle is completed,\nwhether it ends in success or failure. This emitter does not carry any payload (void),\nas it simply serves as a notification that the process is fully complete","api#API":"","example#Example":""}},"/store/reference/asyncGroup/launch":{"title":"launch Property Readonly","data":{"":"An emitter that triggers the start of an asynchronous action.\nThis emitter takes a payload of type L, which contains the necessary data to initiate the action","api#API":"","example#Example":""}},"/store/reference/asyncGroup/state":{"title":"state Property Readonly","data":{"":"The state that tracks the status of an asynchronous action, including counters for successes and\nfailures, as well as flags indicating whether the action is in progress, has completed successfully,\nor has failed","api#API":"","example#Example":""}},"/store/reference/asyncGroup/fail":{"title":"fail Property Readonly","data":{"":"An emitter that triggers when an asynchronous action fails.\nThis emitter takes a payload of type F, which contains the error information or data\nrelated to the failure of the action","api#API":"","example#Example":""}},"/store/reference/asyncGroup/success":{"title":"success Property Readonly","data":{"":"An emitter that triggers when an asynchronous action completes successfully.\nThis emitter takes a payload of type S, which contains the result or data associated\nwith the successful completion of the action","api#API":"","example#Example":""}},"/store/reference/asyncGroup/useCache":{"title":"useCache Method","data":{"":"Enables caching, allowing the results of the asynchronous action\nto be stored and reused based on certain conditions. The cache can be configured to expire\nafter a specified lifetime or to be used conditionally based on a callback function@param secOrFn: number | (() => boolean) \nThe lifetime of the cache in seconds, or a callback function that returns a boolean value.\nIf the callback returns true, the cache will be used@param cacheSize = 10 \nThe maximum number of entries in the cache. If the cache size exceeds this limit, the earliest\nentries will be deleted following a FIFO strategy","api#API":"","example#Example":""}},"/store/reference/asyncGroup/initialize":{"title":"initialize Method","data":{"":"Initiates the group and all its items.In most cases, this method will be called automatically by a group or store managing\nthe group, so you generally don't need to call it manually unless you have a specific\nreason to do so@returns this \nThe instance of the current group, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/changeDefaultComparison":{"title":"changeDefaultComparison Function","data":{"":"Changes the default comparison method that will be used for all states.This can be one of the predefined comparison types: 'equals' for deep comparison,\n'strict' for strict equality, or a custom comparison function@param comparison: Comparison \nThe comparison method to be set as the defaultSee also: Comparison","api#API":"","example#Example":""}},"/store/reference/comparison":{"title":"Comparison Type","data":{"":"Represents a comparison operation, which can be a predefined comparison type or a custom function.The Comparison type allows for different ways to compare two values:\n'equals': A deep comparison using the equals function from the package '@bitfiber/utils'.\n'strict': A strict equality comparison, using strict equality (===).\n((a: any, b: any) => boolean): A custom comparison function that takes two arguments and\nreturns a boolean indicating whether the values are considered equal based on the provided logic","api#API":"","example#Example":""}},"/store/reference/emitterFn":{"title":"emitter Function","data":{"":"Creates and returns a new Emitter instance in a convenient way that provides functionality\nto create streams, handle subscriptions, emit values to subscribers, and integrate with other\nreactive sources such as emitters, states, subjects, observables.You can optionally provide an onInit callback that will be invoked just before the emitter's\ninitialization, allowing you to perform setup tasks or configure the emitter before it starts\nemitting values@template T \nThe type of data emitted by this emitter@param onInit?: (emitter: Emitter<T>) => void \nAn optional callback function that is called with the newly created Emitter instance just before\nits initialization. This function can be used to set up or configure the emitter@returns Emitter<T> See also: Emitter","api#API":"","example#Example":""}},"/store/reference/emitter":{"title":"Emitter Class","data":{"":"Extends the AbstractEmitter class and provides functionality to create streams,\nhandle subscriptions, emit values to subscribers, and integrate with other reactive sources\nsuch as emitters, states, subjects, observables.The Emitter class is typically used when you need a straightforward emitter that can\nbroadcast values or events to all its subscribers or other reactive sources, such as emitters,\nstates, subjects@template T \nThe type of data emitted by this emitter","api#API":"","example#Example":""}},"/store/reference/emitter/emit":{"title":"emit Method","data":{"":"Emits the specified value to all subscribers currently listening to the emitter.\nIt is used to trigger reactive updates or actions in response to the emitted value@param value: T \nThe value to be emitted to all subscribers@returns this \nThe instance of the emitter, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/emitter/complete":{"title":"complete Method","data":{"":"Completes the emitter, signaling to all subscribers that no more values will be emitted.Once the emitter is completed, it will not emit any further values, and any subsequent subscriptions\nwill immediately receive an error.In most cases, this method will be called automatically by a group or store managing the emitter,\nso you generally don't need to call it manually unless you have a specific reason to do so","api#API":"","example#Example":""}},"/store/reference/emitter/$":{"title":"$ Property Readonly","data":{"":"An observable that serves as the source for all emitter streams.\nIt allows subscribers to listen to and react to emitted values or events","api#API":"","example#Example":""}},"/store/reference/emitter/manage":{"title":"manage Method","data":{"":"Defines management operators for all emitter streams.\nThese operators are applied to the streams managed by this emitter,\nallowing you to modify or control their behavior, such as filtering,\nmapping, or handling errors, without altering the type of the emitted values@param ...operators: OperatorFunction<T, T>[] \nOne or more RxJS operators to apply to the emitter streams@returns this \nThe instance of the emitter, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/emitter/initialize":{"title":"initialize Method","data":{"":"Initiates the emitter.\nIn most cases, this method will be called automatically by a group or store managing the emitter,\nso you generally don't need to call it manually unless you have a specific reason to do so@returns this \nThe instance of the emitter, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/emitter/effect":{"title":"effect Method","data":{"":"Creates a new stream with a side effect, similar to the RxJS pipe method.This method allows you to apply a sequence of RxJS operators to the emitter's stream,\nperforming actions or side effects whenever the emitter emits a value. This can be\nparticularly useful for tasks like logging, debugging, or triggering external operations\nin response to emitted values@param ...operators: OperatorFunction<any, any>[] \nA sequence of RxJS operators that define the side effects to be applied to the emitted values@returns this \nThe instance of the emitter, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/emitter/receive":{"title":"receive Method","data":{"overload-1#Overload 1":"Receives values from one or more emitters, states, or observables\nand emits them to all subscribers of this emitter.This method allows this emitter to listen to external sources and relay their\nemitted values to its own subscribers, effectively linking multiple data streams together@param ...inputs: EmitterOrObservable<T>[] \nOne or more emitters, states, or observables that provide values to be emitted by this emitter@returns this \nThe instance of the emitter, allowing for method chaining","api#API":"","example#Example":"","overload-2#Overload 2":"Receives a value from an emitter, state, or observable, applies a reducer function to convert\nthis value to the emitter's type, and emits the result to all subscribers of this emitter.This method allows this emitter to listen to external source and relay the transformed\nemitted value to its own subscribers, effectively linking data streams together@param input: EmitterOrObservable<I> \nAn emitter, state or observable that provide values to be emitted by this emitter@param reducer: (value: I) => T \nA function that converts the received value from its original type to the type expected by this\nemitter, allowing for customization of the emitted value@returns this \nThe instance of the emitter, allowing for method chaining","api-1#API":"","example-1#Example":""}},"/store/reference/group":{"title":"Group Class","data":{"":"Represents a group that collects all subsequently created group items such as emitters, states,\nand groups until group.markAsReady() is called","api#API":"","example#Example":""}},"/store/reference/emitter/transmit":{"title":"transmit Method","data":{"overload-1#Overload 1":"Transmits values from the current emitter to one or more other emitters, states, or subjects.\nIt enables the propagation of data or events across multiple sources, effectively creating\na network of interconnected reactive sources@param ...outputs: (EmitterOrSubject<T> | EmitterOrSubject<void>)[] \nOne or more emitters, states, or subjects that will receive the transmitted values from this emitter@returns this \nThe instance of the emitter, allowing for method chaining","api#API":"","example#Example":"","overload-2#Overload 2":"Transmits values from the current emitter to a state. By using a reducer function,\nthe emitted values can be transformed or customized to match the expected format of the state@param output: AbstractState<O> \nA state that will receive the transmitted values from this emitter@param reducer: (value: T, state: O) => O \nA function that converts or transforms the emitted value from this emitter type to the type expected\nby the state@returns this \nThe instance of the emitter, allowing for method chaining","api-1#API":"","example-1#Example":"","overload-3#Overload 3":"Transmits values from the current emitter to another emitter or subject.\nBy using a reducer function, the emitted values can be transformed or customized to match\nthe expected format of the target emitter or subject@param output: EmitterOrSubject<O> \nAn emitter or subject that will receive the transmitted values from this emitter@param reducer: (value: T) => O \nA function that converts or transforms the emitted value from the current emitter's type to the type\nexpected by the receiving emitter or subject@returns this \nThe instance of the emitter, allowing for method chaining","api-2#API":"","example-2#Example":""}},"/store/reference/emitter/zip":{"title":"zip Method","data":{"":"Combines values from multiple emitters, states, or observables, applies a reducer function to\nthese values, and emits the resulting value to all subscribers of this emitter.The first emission occurs only after all values have been received from the sources, ensuring that\nthe reducer function operates on a complete set of inputs. Subsequent emissions occur only when all\nsources emit new values, triggering the reducer function to recompute the result based on\nthe latest values. Works similarly to the RxJs 'zip' operator@param ...inputs: [...EmitterOrObservableTuple<I>, SpreadFn<I, T>] \nA spread of emitters, states, or observables, followed by a reducer function. The reducer function\ntakes the latest values from each source as arguments and returns the value to be emitted@returns this \nThe instance of the emitter, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/emitter/select":{"title":"select Method","data":{"":"Combines values from multiple emitters, states, or observables, applies a reducer function to\nthese values, and emits the resulting value to all subscribers of this emitter.The first emission occurs only after all values have been received from the sources, ensuring that\nthe reducer function operates on a complete set of inputs. Subsequent emissions occur whenever any\nof the sources emit a new value, triggering the reducer function to recompute the result based on\nthe latest values. Works similarly to the RxJs 'combineLatest' operator@param ...inputs: [...EmitterOrObservableTuple<I>, SpreadFn<I, T>] \nA spread of emitters, states, or observables, followed by a reducer function. The reducer function\ntakes the latest values from each source as arguments and returns the value to be emitted@returns this \nThe instance of the emitter, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/groupFn":{"title":"group Function","data":{"":"Creates a new Group instance that collects all subsequently created group items such as\nemitters, states, and groups until group.markAsReady() is called@returns Group See also: Group","api#API":"","example#Example":""}},"/store/reference/emitter/wait":{"title":"wait Method","data":{"":"Waits for the first values from multiple emitters, states, or observables, applies a reducer\nfunction to these values, emits the resulting value to all subscribers of this emitter,\nand completes the stream@param ...inputs: [...EmitterOrObservableTuple<I>, SpreadFn<I, T>] \nA spread of emitters, states, or observables, followed by a reducer function. The reducer function\ntakes the first values from each source as arguments and returns the value to be emitted@returns this \nThe instance of the emitter, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/group/markAsReady":{"title":"markAsReady Method","data":{"":"Marks the group as ready, indicating that all group items, such as emitters, states, and groups,\nhave been defined.\nThis method must be called after all group items are defined!","api#API":"","example#Example":""}},"/store/reference/namedGroup":{"title":"NamedGroup Class","data":{"":"Represents a named group that extracts emitters, states, and groups from the provided object and\nadds them to the group. Each item is accessible by the key used in the object.@template I extends Index\nExtends Index that contains StoreItem instances and other data, each associated with\na unique key","api#API":"","example#Example":""}},"/store/reference/group/initialize":{"title":"initialize Method","data":{"":"Initiates the group and all its items.In most cases, this method will be called automatically by a group or store managing\nthe group, so you generally don't need to call it manually unless you have a specific\nreason to do so@returns this \nThe instance of the group, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/emitter/tap":{"title":"tap Method","data":{"overload-1#Overload 1":"Creates a new stream with a side effect, similar to the RxJS tap operator.This method allows you to perform actions or side effects whenever the emitter emits a value,\nwithout altering the value itself. It is useful for tasks like logging, debugging,\nor triggering external operations in response to emitted values@param observer: Partial<Observer<T>> \nA partial observer with lifecycle methods (next, error, complete)@returns this \nThe instance of the emitter, allowing for method chaining","api#API":"","example#Example":"","overload-2#Overload 2":"Creates a new stream with a side effect, similar to the RxJS tap operator.This method allows you to perform actions or side effects whenever the emitter emits a value,\nwithout altering the value itself. It is useful for tasks like logging, debugging,\nor triggering external operations in response to emitted values@param next: (value: T) => void \nA function that takes the emitted value and performs a side effect@returns this \nThe instance of the emitter, allowing for method chaining","api-1#API":"","example-1#Example":""}},"/store/reference/namedGroupFn":{"title":"namedGroup Function","data":{"":"Creates a new NamedGroup instance that extracts emitters, states, and groups from the provided\nobject and adds them to the group. Each item is accessible by the key used in the object.This function also allows for an optional onInit callback, which can be used to perform\nadditional setup or configuration just before the group initialization@template I extends Index \nThe type of the index used to access the StoreItem instances in the group@param index: I \nAn index that contains StoreItem instances and other data, each associated with a unique key@param onInit?: (group: NamedGroup<StoreIndex<I>>, sameGroup: NamedGroup<StoreIndex<I>>) => void \nAn optional callback function that is executed just before initialization@returns NamedGroup<StoreIndex<I>> See also: NamedGroup","api#API":"","example#Example":""}},"/store/reference/group/complete":{"title":"complete Method","data":{"":"Completes the group and all its items, signaling to all item subscribers that no more values\nwill be emitted.Once the group is completed, Its items will no longer emit any values, and any subsequent\nsubscriptions will immediately receive an error.In most cases, this method will be called automatically by a group or store managing the group,\nso you generally don't need to call it manually unless you have a specific reason to do so","api#API":"","example#Example":""}},"/store/reference/state/$":{"title":"$ Property Readonly","data":{"":"An observable that serves as the source for all state streams.\nIt allows subscribers to reactively observe changes or updates to the state, allowing them to\nrespond dynamically as new values are emitted","api#API":"","example#Example":""}},"/store/reference/state":{"title":"State Class","data":{"":"Represents a concrete state in a reactive store, extending the functionality of AbstractState.\nThis class encapsulates the logic for updating, resetting and maintaining a state, reacting to\nchanges, and notifying subscribers whenever the state is updated.It can also be connected to external data sources to synchronize its value with external data,\nensuring consistency across different parts of an application@template T \nThe type of data managed and emitted by the state","api#API":"","example#Example":""}},"/store/reference/namedGroup/complete":{"title":"complete Method","data":{"":"Completes the group and all its items, signaling to all item subscribers that no more values\nwill be emitted.Once the group is completed, Its items will no longer emit any values, and any subsequent\nsubscriptions will immediately receive an error.In most cases, this method will be called automatically by a group or store managing the group,\nso you generally don't need to call it manually unless you have a specific reason to do so","api#API":"","example#Example":""}},"/store/reference/stateFn":{"title":"state Function","data":{"":"Creates an instance that combines the functionality of both the State class and the StateGetter\nfunction, initialized with the provided initialValue.Optionally, you can provide an onInit callback function, which is called just before\nthe initialization process, allowing you to perform setup tasks or configure the state before\nit starts emitting values@template T \nThe type of the state value@param initialValue: T \nThe initial value of the state@param onInit?: (state: StateType<T>) => void \nAn optional callback function that is executed just before the initialization of the state,\nallowing you to perform setup tasks or configure the state before it starts emitting values@returns StateType<T> \nA new State instance that also acts as the StateGetter function to get the current state valueSee also: State","api#API":"","example#Example":""}},"/store/reference/state/initialize":{"title":"initialize Method","data":{"":"Initiates the state.\nIn most cases, this method will be called automatically by a group or store managing\nthe state, so you generally don't need to call it manually unless you have a specific\nreason to do so@returns this \nThe current instance of the store, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/state/connect":{"title":"connect Method","data":{"":"Connects the state to an external data source DataSource, which provides the data\nthat the state will manage and emit. By connecting to a data source, the state can synchronize\nwith external data, ensuring it remains consistent with the source. This is useful in scenarios\nwhere the state needs to reflect or react to data from an external provider.Once connected, the state automatically updates from the data source whenever the source changes,\nand conversely, updates the data source whenever the state value is changed. This bidirectional\nsynchronization ensures that both the state and the data source remain in sync@param source: DataSource<T> \nThe external data source to connect to the state@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/namedGroup/initialize":{"title":"initialize Method","data":{"":"Initiates the group and all its items.In most cases, this method will be called automatically by a group or store managing\nthe group, so you generally don't need to call it manually unless you have a specific\nreason to do so@returns this \nThe instance of the group, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/state/complete":{"title":"complete Method","data":{"":"Completes the state, signaling to all subscribers that no more values will be emitted.Once the state is completed, it will not emit any further values, and any subsequent subscriptions\nwill immediately receive an error.In most cases, this method will be called automatically by a group or store managing the state,\nso you generally don't need to call it manually unless you have a specific reason to do so","api#API":"","example#Example":""}},"/store/reference/state/manage":{"title":"manage Method","data":{"":"Defines management operators for all state streams. These operators are applied to the streams\nmanaged by this state, allowing you to modify or control their behavior, such as filtering,\nmapping, or handling errors, without altering the type of the emitted values@param ...operators: OperatorFunction<T, T>[] \nOne or more RxJS operators to apply to the state streams@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/state/get":{"title":"get Method","data":{"":"Returns the current value of the state.\nThis method is useful for accessing the state at any point in time,\nallowing other store items or consumers to retrieve the latest value@returns T","api#API":"","example#Example":""}},"/store/reference/state/compareBy":{"title":"compareBy Method","data":{"":"Sets a custom comparison strategy that will be used to determine if the state has changed.\nThis comparison can be one of the predefined comparison types ('equals' or 'strict')\nor a custom comparison function@param comparison: Comparison \nThe comparison method to use for evaluating state changes@returns this \nThe instance of the current state, allowing for method chainingSee also: Comparison","api#API":"","example#Example":""}},"/store/reference/state/effect":{"title":"effect Method","data":{"":"Creates a new stream with a side effect, similar to the RxJS pipe method.This method allows you to apply a sequence of RxJS operators to the state's stream,\nperforming actions or side effects whenever the state emits a value. This can be\nparticularly useful for tasks like logging, debugging, or triggering external operations\nin response to emitted values@param ...operators: OperatorFunction<any, any>[] \nA sequence of RxJS operators that define the side effects to be applied to the emitted values@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/state/reset":{"title":"reset Method","data":{"":"Resets the state to its original value that was set during initialization.\nThis is useful for reverting the state back to its starting condition, discarding any changes\nthat have occurred since the state was first established@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/state/receive":{"title":"receive Method","data":{"overload-1#Overload 1":"Receives values from one or more emitters, states, or observables\nand emits them to all subscribers of this state.This method allows this state to listen to external sources and relay their\nemitted values to its own subscribers, effectively linking multiple data streams together@param ...inputs: EmitterOrObservable<T>[] \nOne or more emitters, states, or observables that provide values to be emitted by this state@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":"","overload-2#Overload 2":"Receives a value from an emitter, state, or observable, applies a reducer function to convert\nthis value to the state's type, and emits the result to all subscribers of this state.This method allows this state to listen to external source and relay the transformed\nemitted value to its own subscribers, effectively linking data streams together@param input: EmitterOrObservable<I> \nAn emitter, state or observable that provide values to be emitted by this state@param reducer: (value: I, state: T) => T \nA function that converts or transforms the received value from the input type to the type expected\nby this state. This function takes the value emitted by the input and this state value as\nparameters, and returns the new state value@returns this \nThe instance of the current state, allowing for method chaining","api-1#API":"","example-1#Example":""}},"/store/reference/state/tap":{"title":"tap Method","data":{"overload-1#Overload 1":"Creates a new stream with a side effect, similar to the RxJS tap operator.This method allows you to perform actions or side effects whenever the state emits a value,\nwithout altering the value itself. It is useful for tasks like logging, debugging,\nor triggering external operations in response to emitted values@param observer: Partial<Observer<T>> \nA partial observer with lifecycle methods (next, error, complete)@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":"","overload-2#Overload 2":"Creates a new stream with a side effect, similar to the RxJS tap operator.This method allows you to perform actions or side effects whenever the state emits a value,\nwithout altering the value itself. It is useful for tasks like logging, debugging,\nor triggering external operations in response to emitted values@param next: (value: T) => void \nA function that takes the emitted value and performs a side effect@returns this \nThe instance of the current state, allowing for method chaining","api-1#API":"","example-1#Example":""}},"/store/reference/state/select":{"title":"select Method","data":{"":"Combines values from multiple emitters, states, or observables, applies a reducer function to\nthese values, and emits the resulting value to all subscribers of this state.The first emission occurs only after all values have been received from the sources, ensuring that\nthe reducer function operates on a complete set of inputs. Subsequent emissions occur whenever any\nof the sources emit a new value, triggering the reducer function to recompute the result based on\nthe latest values. Works similarly to the RxJs 'combineLatest' operator@param ...inputs: [...EmitterOrObservableTuple<I>, SpreadFn<I, T>] \nA spread of emitters, states, or observables, followed by a reducer function. The reducer function\ntakes the latest values from each source as arguments and returns the value to be emitted@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/state/update":{"title":"update Method","data":{"":"Updates the current state using an updater function that takes the current state value as its\nargument and returns the new state value. The state is updated immediately, but the emission\nof this new value to subscribers will occur asynchronously. This means that if multiple\nsynchronous updates are made in quick succession, only the last update will be emitted,\noptimizing the emission process to prevent unnecessary updates@param updater: (state: T) => T \nA function that takes the current state value as its argument and returns the new state value@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/state/useLazyEmission":{"title":"useLazyEmission Method","data":{"":"Enables lazy emission for the state, meaning that the state will defer emitting its initial value\nto subscribers until an explicit trigger occurs. This can be useful in scenarios where you want\nmore control over when the state emits its value, rather than emitting immediately@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/state/set":{"title":"set Method","data":{"":"Updates the state to the provided value immediately, but the emission of this\nnew value to subscribers will be performed asynchronously. This means that if multiple\nsynchronous updates are made in quick succession, only the last update will be emitted,\noptimizing the emission process to prevent unnecessary updates@param value: T \nThe new value to set as the current state@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/state/useLazyEmissionOnce":{"title":"useLazyEmissionOnce Method","data":{"":"Enables one-time lazy emission for the next created stream.Once the useLazyEmissionOnce method is called, the state will defer emitting its initial value\nuntil an explicit trigger occurs. This lazy emission behavior will apply only once for the next\nstream that is created. After this initial deferred emission, subsequent streams will emit values\nimmediately as changes occur.This method can be called multiple times before creating streams, allowing you to control\nwhen the lazy emission behavior is applied.By default, one-time lazy emission is disabled, meaning that streams will emit their initial\nvalues immediately upon creation unless this behavior is explicitly overridden@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/store":{"title":"Store Class Abstract","data":{"":"The Store class is a foundational component for implementing reactive state management and\nhandling asynchronous data flow in modules or entire applications. It serves as a central hub,\norganizing and managing store items like emitters, states, and groups, ensuring seamless\ninteraction among them.Stores can also include methods to trigger specific actions, making them a powerful and\nflexible tool for coordinating complex application logic. Their structured design simplifies\nthe development of scalable, maintainable, and reactive applications, ensuring consistency and\nclarity in managing state and data flow.By implementing the StoreHooks interface, the store provides lifecycle hooks for executing custom\nlogic before and after key events, such as store initialization and completion.The Store class is an abstract foundation designed to serve as a base for specific store\nimplementations that define concrete collections of store itemsSee also: StoreHooks","api#API":"","example#Example":""}},"/store/reference/state/wait":{"title":"wait Method","data":{"":"Waits for the first values from multiple emitters, states, or observables, applies a reducer\nfunction to these values, emits the resulting value to all subscribers of this state,\nand completes the stream@param ...inputs: [...EmitterOrObservableTuple<I>, SpreadFn<I, T>] \nA spread of emitters, states, or observables, followed by a reducer function. The reducer function\ntakes the first values from each source as arguments and returns the value to be emitted@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/state/zip":{"title":"zip Method","data":{"":"Combines values from multiple emitters, states, or observables, applies a reducer function to\nthese values, and emits the resulting value to all subscribers of this state.The first emission occurs only after all values have been received from the sources, ensuring that\nthe reducer function operates on a complete set of inputs. Subsequent emissions occur only when all\nsources emit new values, triggering the reducer function to recompute the result based on\nthe latest values. Works similarly to the RxJs 'zip' operator@param ...inputs: [...EmitterOrObservableTuple<I>, SpreadFn<I, T>] \nA spread of emitters, states, or observables, followed by a reducer function. The reducer function\ntakes the latest values from each source as arguments and returns the value to be emitted@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":""}},"/store/reference/storeHooks/afterStoreInit":{"title":"afterStoreInit Method","data":{"":"An optional hook that runs after the store has been initialized","api#API":"","example#Example":""}},"/store/reference/storeHooks":{"title":"StoreHooks Interface","data":{"":"Represents optional hooks for Store that can be implemented to perform\nactions before and after the store is initialized and completedSee also: Store","api#API":"","example#Example":""}},"/store/reference/storeHooks/beforeStoreComplete":{"title":"beforeStoreComplete Method","data":{"":"An optional hook that runs before the store is completed","api#API":"","example#Example":""}},"/store/reference/storeHooks/beforeStoreInit":{"title":"beforeStoreInit Method","data":{"":"An optional hook that runs before the store is initialized","api#API":"","example#Example":""}},"/store/reference/state/transmit":{"title":"transmit Method","data":{"overload-1#Overload 1":"Transmits values from the current state to one or more other emitters, states, or subjects.\nIt enables the propagation of data or events across multiple sources, effectively creating\na network of interconnected reactive sources@param ...outputs: (EmitterOrSubject<T> | EmitterOrSubject<void>)[] \nOne or more emitters, states, or subjects that will receive the transmitted values from this state@returns this \nThe instance of the current state, allowing for method chaining","api#API":"","example#Example":"","overload-2#Overload 2":"Transmits values from the current state to another state. By using a reducer function,\nthe emitted values can be transformed or customized to match the expected format of another state@param output: AbstractState<O> \nA state that will receive the transmitted values from this state@param reducer: (value: T, state: O) => O \nA function that converts or transforms the emitted value from this state type to the type expected\nby another state@returns this \nThe instance of the current state, allowing for method chaining","api-1#API":"","example-1#Example":"","overload-3#Overload 3":"Transmits values from the current state to another emitter or subject.\nBy using a reducer function, the emitted values can be transformed or customized to match\nthe expected format of the target emitter or subject@param output: EmitterOrSubject<O> \nAn emitter or subject that will receive the transmitted values from this state@param reducer: (value: T) => O \nA function that converts or transforms the emitted value from the current state's type to the type\nexpected by the receiving emitter or subject@returns this \nThe instance of the current state, allowing for method chaining","api-2#API":"","example-2#Example":""}},"/store/reference/storeHooks/afterStoreComplete":{"title":"afterStoreComplete Method","data":{"":"An optional hook that runs after the store has been completed","api#API":"","example#Example":""}},"/store/reference/store/initialize":{"title":"initialize Method","data":{"":"Initializes the store and all of its items, preparing it for use. Optionally, a beforeInit\ncallback function can be provided, which will be executed before the store is initialized@param beforeInit?: (store: this) => void \nAn optional callback function that runs before the store is initialized@returns this \nThe current instance of the store, allowing for method chaining","api#API":"","example#Example":""}},"/store/states":{"title":"States","data":{"":"States are the core data containers in the reactive store, responsible for maintaining and\nbroadcasting data updates to multiple subscribers. Like emitters, states can create and manage\nreactive streams to broadcast changes efficiently. They are designed to simplify state\npropagation and synchronization across stores or features, ensuring consistency. States can also\nintegrate seamlessly with other reactive sources like emitters, states, and observables.","creating-a-state#Creating a State":"","basic-state#Basic State":"To create State, use the state function:","state-with-interaction-logic#State with Interaction Logic":"To add interaction logic with other reactive sources, use the onInit callback. This ensures\nsubscriptions and emissions occur only after the store is initialized:","getting-current-data#Getting Current Data":"States allow you to get current data using get method or calling\nthe state like a function:","updating-state#Updating State":"States allow you to update their data and send updated data to their subscribers, effects, and any\nconnected reactive sources using set and\nupdate methods.The set method directly sets a new value:\nThe update method computes a new value based on the current value:","resetting-state#Resetting State":"You can reset the state to its initial value using the reset method:","receiving-data#Receiving Data":"States can receive data from various reactive sources like emitters, states, and observables,\nupdating their data and transmitting it to subscribers.","methods-for-receiving-data#Methods for Receiving Data":"receive method\nStates can receive data from other reactive sources using the receive method.Without Data Transformation\nWith Data Transformation\nselect method\nCombines data from all sources, updates its data by a computed value, and emits a computed value\nwhenever any source emits:\nzip method\nCombines data from all sources, updating its data by a computed value and emitting a computed value\nonly when all sources emit new values:\nwait method\nWaits for the first values from all sources, updates its data by a computed value, emits\na computed value, and completes the stream:","working-with-observables#Working with Observables":"States can receive data from observables, which allows you to use RxJS operators for more\nadvanced stream manipulation before connecting them to states.","transmitting-data#Transmitting Data":"States can transmit their updated data to other reactive sources using\nthe transmit method.","without-data-transformation#Without Data Transformation":"","with-data-transformation#With Data Transformation":"","creating-side-effects#Creating Side Effects":"States support creating side effects using tap and\neffect methods.","using-tap#Using Tap":"The tap method performs a side effect whenever the state emits a value.","using-effect#Using Effect":"The effect method allows for complex stream management using RxJS operators.","comparison-type#Comparison Type":"States evaluate changes using a specific Comparison type.\nBy default, states use the equals comparison type, which ensures data is updated only when\nvalues are different based on deep equality checks.You can change the comparison type for a specific state using\nthe compareBy method:\nTo globally change the default comparison type for all states in your application, use\nthe changeDefaultComparison function:","lazy-emission#Lazy Emission":"In scenarios where immediate emission is not desirable at the time of subscription, use\nthe useLazyEmission or\nuseLazyEmissionOnce methods.","for-all-subscriptions#For All Subscriptions":"","for-the-next-subscription#For the Next Subscription":"","synchronizing-with-data-sources#Synchronizing with Data Sources":"State can be synchronized with external data sources that implement\nthe DataSource interface like\nlocalStoragePart. For this, use\nthe connect method.Once connected, the state automatically updates from the data source whenever the source changes,\nand conversely, updates the data source whenever the state value is changed. This bidirectional\nsynchronization ensures that both the state and the data source remain in sync.","managing-all-streams#Managing All Streams":"States allow you to apply RxJS operators across all their streams simultaneously using\nthe manage method. This ensures consistent stream behavior\nby applying the same operators to all streams generated by the state."}},"/store/reference/store/complete":{"title":"complete Method","data":{"":"Completes the store and all of its items, signaling that the store has finished\nits operations and is now in a completed state. Once the store is completed,\nno further changes or updates will be made to it or its items.\nThis method is called automatically when the associated component or service is destroyed","api#API":"","example#Example":""}},"/store/reference/store/markAsReady":{"title":"markAsReady Method Protected","data":{"":"Marks the store as ready, indicating that all store items, such as emitters, states, and groups,\nhave been defined.\nThis method must be called after all store items are defined!","api#API":"","example#Example":""}},"/store/reference/transmit":{"title":"transmit Function","data":{"":"Transmits the result of the asynchronous action to the provided emitter or group, allowing success,\nfailure, and completion actions or effects to be performed. It can also transmit to additional\nemitters for failure and finish actions or effects@template L \nThe type representing the data for the launch emitter@template S \nThe type representing the data for the success emitter@template F \nThe type representing the error data for the fail emitter@param emitterOrGroup: AbstractEmitter<S> | Subject<S> | AbstractAsyncGroup<L, S, F> \nThe primary emitter, state, subject, or async group that will receive the success data@param failEmitter?: AbstractEmitter<F> | Subject<F> | null \nAn optional emitter, state, or subject that will emit the failure data after a failed action@param finishEmitter?: AbstractEmitter<void> | Subject<void> \nAn optional emitter, state, or subject that will emit once the asynchronous action is completed,\neither successfully or with a failure@returns OperatorFunction<S, S> \nAn RxJS operator that transmits the data to the corresponding emitterSee also: asyncGroup","api#API":"","example#Example":""}},"/":{"title":"@bitfiber/rx - Reactive State and Async Workflow Management Library","data":{"":"@bitfiber/rx is a powerful and flexible library built on top of RxJS, tailored for managing\nreactive state, asynchronous workflows, and events in modern JavaScript applications. It introduces\na structured approach to handle complex data flows through key components such as emitters, states,\ngroups, and stores.This library seamlessly integrates various reactive sources like emitters, states, and observables,\nenabling a cohesive and efficient workflow. Emitters and states can be organized into groups and\nstores, streamlining management and lifecycle control for related reactive components.Whether you're working on small or large-scale applications, @bitfiber/rx simplifies reactive\nprogramming, making it more efficient and maintainable.","key-components#Key Components":"","store#Store":"The Store is a foundational component for implementing reactive state management and\nhandling asynchronous data flow in modules or entire applications. It serves as a central hub,\norganizing and managing store items like emitters, states, and groups, ensuring seamless\ninteraction among them.","emitters#Emitters":"Emitters are fundamental units of communication in the reactive store. They enable straightforward\ncreation and management of reactive streams, integrating seamlessly with other reactive sources\nlike emitters, states, and observables. This integration allows you to build complex networks of\nstreams and effectively manage reactive data flows.","states#States":"States are the core data containers in the reactive store, responsible for maintaining and\nbroadcasting data updates to multiple subscribers. Like emitters, states can create and manage\nreactive streams to broadcast changes efficiently. They are designed to simplify state\npropagation and synchronization across stores or features, ensuring consistency. States can also\nintegrate seamlessly with other reactive sources like emitters, states, and observables.","groups#Groups":"Groups are collections of emitters, states, and other groups that are unified under a specific\nfeature. They help organize related reactive sources into a cohesive structure, ensuring proper\ninitialization and completion of all items as a single unit.","data-sources#Data Sources":"Data sources act as facades for specific parts of data in external storages like local storage,\nsession storage, cookies, and more. They implement a unified interface called DataSource,\nwhich simplifies integration with various storage mechanisms. This interface also enables states to\nseamlessly connect to external storages, ensuring that state remains synchronized with them.","key-features#Key Features":"Integration with RxJS\nSince @bitfiber/rx is built on top of RxJS, it integrates smoothly with the RxJS ecosystem.\nEmitters and states can easily interact with observables and subjects, and can also create\neffects using RxJS operators.\nStream Connections\nEasily connects multiple emitters, states, and observables to each other.\nReadable Code Structure\nProduces clear, traceable code, making connections between emitters, states, and\nobservables easy to follow.\nAutomatic Subscription Management\nSimplifies handling reactive streams, freeing you from managing manual subscriptions\nand completions.\nSynchronization with Data Sources\nStates can synchronize with data sources like local storage, cookies, and\nother external data sources.\nStrict Typing\nThe library leverages TypeScript to enforce strict typing, ensuring robust type checking\nat compile time. This reduces the likelihood of runtime errors and enhances code reliability.\nTypeScript's powerful type inference also makes it easier to write cleaner, more maintainable code,\nproviding developers with strong guarantees about the structure and behavior of their reactive\ncomponents.\nTree Shaking\nThe modular design of @bitfiber/rx enables tree shaking, allowing developers to optimize\nbundle sizes by importing only the required functionalities. This eliminates unused code from\nthe final build, leading to smaller, more efficient applications, which is particularly useful\nfor performance-sensitive environments."}},"/sources/reference/memoryStorage":{"title":"MemoryStorage Class","data":{"":"Implements the KeyValueSource interface and allows storing, retrieving, observing, and managing\nkey-value pairs directly in memory. It provides a simple storage mechanism that exists only during\nthe runtime of the application@template T = any \nThe type of data stored in the memory storage. Defaults to anySee also: KeyValueSource","api#API":"","example#Example":""}}}