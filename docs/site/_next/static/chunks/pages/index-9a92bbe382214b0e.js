(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3332],{72574:(e,n,s)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return s(15080)}])},15080:(e,n,s)=>{"use strict";s.r(n),s.d(n,{default:()=>l,useTOC:()=>o});var t=s(62540),i=s(7933),r=s(24759),a=s(98795);function o(e){let n={a:"a",...(0,a.R)()};return[{value:"Key Components",id:"key-components",depth:2},{value:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)(n.a,{href:"/store",children:"Store"})}),id:"store",depth:3},{value:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)(n.a,{href:"/store/emitters",children:"Emitters"})}),id:"emitters",depth:3},{value:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)(n.a,{href:"/store/states",children:"States"})}),id:"states",depth:3},{value:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)(n.a,{href:"/store/groups",children:"Groups"})}),id:"groups",depth:3},{value:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)(n.a,{href:"/sources",children:"Data Sources"})}),id:"data-sources",depth:3},{value:"Key Features",id:"key-features",depth:2}]}let l=(0,i.e)(function(e){let{toc:n=o(e)}=e,s={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{children:"@bitfiber/rx - Reactive State and Async Workflow Management Library"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"@bitfiber/rx"})," is a powerful and flexible library built on top of ",(0,t.jsx)(s.a,{href:"https://rxjs.dev",children:"RxJS"}),", tailored for managing\nreactive state, asynchronous workflows, and events in modern JavaScript applications. It introduces\na structured approach to handle complex data flows through key components such as emitters, states,\ngroups, and stores."]}),"\n",(0,t.jsx)(s.p,{children:"This library seamlessly integrates various reactive sources like emitters, states, and observables,\nenabling a cohesive and efficient workflow. Emitters and states can be organized into groups and\nstores, streamlining management and lifecycle control for related reactive components."}),"\n",(0,t.jsxs)(s.p,{children:["Whether you’re working on small or large-scale applications, ",(0,t.jsx)(s.code,{children:"@bitfiber/rx"})," simplifies reactive\nprogramming, making it more efficient and maintainable."]}),"\n",(0,t.jsx)(s.h2,{id:n[0].id,children:n[0].value}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.h3,{id:n[1].id,children:n[1].value}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"The Store is a foundational component for implementing reactive state management and\nhandling asynchronous data flow in modules or entire applications. It serves as a central hub,\norganizing and managing store items like emitters, states, and groups, ensuring seamless\ninteraction among them."}),"\n",(0,t.jsxs)(s.ol,{start:"2",children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.h3,{id:n[2].id,children:n[2].value}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Emitters are fundamental units of communication in the reactive store. They enable straightforward\ncreation and management of reactive streams, integrating seamlessly with other reactive sources\nlike emitters, states, and observables. This integration allows you to build complex networks of\nstreams and effectively manage reactive data flows."}),"\n",(0,t.jsxs)(s.ol,{start:"3",children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.h3,{id:n[3].id,children:n[3].value}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"States are the core data containers in the reactive store, responsible for maintaining and\nbroadcasting data updates to multiple subscribers. Like emitters, states can create and manage\nreactive streams to broadcast changes efficiently. They are designed to simplify state\npropagation and synchronization across stores or features, ensuring consistency. States can also\nintegrate seamlessly with other reactive sources like emitters, states, and observables."}),"\n",(0,t.jsxs)(s.ol,{start:"4",children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.h3,{id:n[4].id,children:n[4].value}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Groups are collections of emitters, states, and other groups that are unified under a specific\nfeature. They help organize related reactive sources into a cohesive structure, ensuring proper\ninitialization and completion of all items as a single unit."}),"\n",(0,t.jsxs)(s.ol,{start:"5",children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.h3,{id:n[5].id,children:n[5].value}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Data sources act as facades for specific parts of data in external storages like local storage,\nsession storage, cookies, and more. They implement a unified interface called ",(0,t.jsx)(s.a,{href:"/sources/reference/dataSource",children:"DataSource"}),",\nwhich simplifies integration with various storage mechanisms. This interface also enables states to\nseamlessly connect to external storages, ensuring that state remains synchronized with them."]}),"\n",(0,t.jsx)(s.h2,{id:n[6].id,children:n[6].value}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Integration with RxJS"}),(0,t.jsx)(s.br,{}),"\n","Since ",(0,t.jsx)(s.code,{children:"@bitfiber/rx"})," is built on top of RxJS, it integrates smoothly with the RxJS ecosystem.\nEmitters and states can easily interact with observables and subjects, and can also create\neffects using RxJS operators."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Stream Connections"}),(0,t.jsx)(s.br,{}),"\n","Easily connects multiple emitters, states, and observables to each other."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Readable Code Structure"}),(0,t.jsx)(s.br,{}),"\n","Produces clear, traceable code, making connections between emitters, states, and\nobservables easy to follow."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Automatic Subscription Management"}),(0,t.jsx)(s.br,{}),"\n","Simplifies handling reactive streams, freeing you from managing manual subscriptions\nand completions."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Synchronization with Data Sources"}),(0,t.jsx)(s.br,{}),"\n","States can synchronize with data sources like local storage, cookies, and\nother external data sources."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Strict Typing"}),(0,t.jsx)(s.br,{}),"\n","The library leverages TypeScript to enforce strict typing, ensuring robust type checking\nat compile time. This reduces the likelihood of runtime errors and enhances code reliability.\nTypeScript’s powerful type inference also makes it easier to write cleaner, more maintainable code,\nproviding developers with strong guarantees about the structure and behavior of their reactive\ncomponents."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Tree Shaking"}),(0,t.jsx)(s.br,{}),"\n","The modular design of ",(0,t.jsx)(s.code,{children:"@bitfiber/rx"})," enables tree shaking, allowing developers to optimize\nbundle sizes by importing only the required functionalities. This eliminates unused code from\nthe final build, leading to smaller, more efficient applications, which is particularly useful\nfor performance-sensitive environments."]}),"\n"]}),"\n"]})]})},"/",{filePath:"pages/index.mdx",pageMap:r.O,frontMatter:{},title:"@bitfiber/rx - Reactive State and Async Workflow Management Library"},"undefined"==typeof RemoteContent?o:RemoteContent.useTOC)}},e=>{var n=n=>e(e.s=n);e.O(0,[7933,4759,636,6593,8792],()=>n(72574)),_N_E=e.O()}]);